{"name":"Gnuprolog-redisclient","tagline":"A simple but effective pure GNU Prolog client connecting with Redis, no libraries required.","body":"gnuprolog-redisclient\r\n=====================\r\nA simple but effective pure native GNU Prolog client connecting with Redis\r\n(min. 2.8), no other libraries required.\r\n\r\nWhat it does\r\n============\r\nProvides a 100% pure Prolog implementation for GNU Prolog that allows your code to connect to a Redis server, local or remote, and perform the large majority of commands allowing you to have the power of Redis for use in your application.\r\n\r\nRequirements\r\n============\r\nThis has been written with GNU Prolog 1.4.4 and against Redis 2.8.0. It was developed on OSX Mavericks but should be fine anywhere you can get GNU Prolog to run.\r\n\r\n\r\nLimitations\r\n===========\r\nIt doesn't support anything that requires blocking or a persistent connection to receive data (yet) that is to say, you couldn't use it for subscribing to a channel.\r\n\r\nIf you want it to do something and it doesn't, get in touch and I will see what I can do. I already plan to refactor it soon to make it work with SWI Prolog as well, I mainly use GNU but SWI is pretty popular so I will make that happen when I can.\r\n\r\nRunning the tests\r\n=================\r\nI wrote a very simple unit testing framework for this. In the folder `tests` you will find some BASH scripts, the one I use most of the time is \r\n\r\n    ./runalltests\r\n\r\nwhich outputs a very simple trace of the tests. *Make sure Redis is running* before you start it. If it hangs then you will have to CTRL-C and then quit GNU Prolog and try again.\r\n\r\nThe test framework is in `testing_framework.pl`  and is as simple as I could make it. Prolog is ideally suited for this and so as I got the hang of it I realised that I could rely on Unification more generally in my tests scripts and resort to using `tf_equals` only when a test failed and needed sorting out. Again, it's simple but effective and did the job.\r\n\r\n\r\nUsing it\r\n========\r\nThe simplest way to see how to use it is to look at one of the test scripts.\r\nMany thanks to Daniel Diaz for some helpful information on getting the test harness to execute tests in file order.\r\n\r\n\r\nConsole Mode\r\n------------\r\nIf you want to be able to use Redis as though you where connected to a command\r\nline client like \"redis-cli\" then you use the \"redis\" predicate. This takes just the command and writes all of the output to the console.\r\n\r\n\r\nProgrammatic Mode\r\n-----------------\r\nIf you want to create a session and then perform reads and writes during the\r\ncourse of you application then you need to use the `redis_connect` group of predicates.\r\n\r\n\r\nConsole Mode Examples\r\n=====================\r\n\r\nOK, well some examples I guess. These assume that you have cloned the project\r\nand have changed into the working folder.\r\n\r\nFirst *ensure that Redis is running*, obvious I know but... I wrote this\r\nagainst 2.8 as I tend to stay with the latest of versions of things when I can\r\nto try out new features.\r\n\r\nOnce Redis is running, you can then start a GNU Prolog session and load the code:\r\n\r\n    Seans-iMac:gprolog-redis seancharles$ \r\n    Seans-iMac:gprolog-redis seancharles$ gprolog\r\n    GNU Prolog 1.4.4 (64 bits)\r\n    Compiled Oct 13 2013, 17:19:55 with cc\r\n    By Daniel Diaz\r\n    Copyright (C) 1999-2013 Daniel Diaz\r\n    | ?- [gpredis].\r\n    compiling /Users/seancharles/Documents/github/gprolog-redis/gpredis.pl\r\n    for byte code...\r\n    /Users/seancharles/Documents/github/gprolog-redis/gpredis.pl compiled, \r\n    196 lines read - 15940 bytes written, 9 ms\r\n\r\n    (3 ms) yes\r\n    | ?- \r\n\r\nOK, we should be good to go now with some redis commands! This is acheived through the use of the `redis()` predicate. There are no actual commands in the code that map to any of the redis server commands, instead, because the protocol is so beautifully simple and well thought out, it was easier to use the `=..` (univ) operator to deconstruct an ad-hoc term into the actual command string.\r\n\r\nFor example, here is how you would list all the keys or just some of the keys\r\nmatching a pattern:\r\n\r\n```prolog\r\n| ?- redis(keys(*)).\r\n| ?- redis(keys('users:*:last_logged_in_time')).\r\n```\r\n\r\nAtoms or strings are acceptable. Here are some other example commands to get\r\nyou started. The \"rule\" is that the functor name of the argument to `redis()` is\r\nthe first part of the command and the arguments are then used to form the\r\nremainder of the command.\r\n\r\n```prolog\r\n| ?- redis(set(hairy_key_name, \"a value\")).\r\n| ?- redis(get(hairy_key_name)).\r\n```\r\n\r\nBasically, load up your redis with data and then play with it. The rule is:\r\n\r\n  **`redis( command, arg1, arg2, ... argN )`**\r\n\r\nHere are some more console mode examples:\r\n\r\n```prolog\r\n| ?- redis(flushall).\r\n| ?- redis(set(test_string, 'GNU Prolog')).\r\n| ?- redis(append(test_string, ' is Cool')).\r\n| ?- redis(echo('GNU Prolog rocks!')).\r\n| ?- redis(lpush(test_list, 42)).\r\n| ?- redis(llen(test_list)).\r\n| ?- redis(lrange(test_list, 0, -1)).\r\n| ?- redis(lpop(test_list)).\r\n| ?- redis(rpop(test_list)).\r\n| ?- redis(exists(test_hash), number(0)).\r\n| ?- redis(hset(test_hash, name, 'Emacs The Viking'), number(1)).\r\n| ?- redis(hmset(test_hash,\tnew_field_1, \"Hello\", new_field_2, \"World\")).\r\n| ?- redis(hdel(test_hash, unknown)).\r\n| ?- redis(hlen(test_hash)).\r\n```\r\n\t\r\n\r\nRedis commands consisting of multiple verbs\r\n-------------------------------------------\r\nSome commands are more than one word, such as `client setname` for example, and `config get` and `config set`. The same rule applies however, functor name is the first verb and the rest is still just argument data:\r\n\r\n```prolog\r\nredis_do(C, client(setname, \"Objitsu\"), status(Set)),\r\nredis_do(C, client(getname), bulk(Get)),\r\nredis_do(C, config(set, timeout, 86400), status(Set)),\r\nredis_do(C, config(get, timeout), [bulk(Key), bulk(Val)]),\r\n```\r\n\r\nAll response data goes to the console and that's it. Simples. Each line of data will be preceded by an indicator of the type that was returned:\r\n\r\n  * NUMBER: an integer was decoded\r\n  * STRING: a bulk string was decoded\r\n  * STATUS: a status response was decoded\r\n  * NIL     a nil response (-1) was decoded.\r\n  \r\nThere is a predicate called `redis_print` that you can use to dump out the response in your code if you like when using the programmatic API.\r\n\r\n\r\nProgram Examples\r\n================\r\n\r\nRedis returns either integers or (mostly) strings or lists of them. Initially I returned everything as strings but then I went a little further and eventually for purely selfish reasons I decided that I would wrap the returned data in a functor that described the underlying Redis return type in case the application code wanted or needed to know.\r\n\r\n**Please read the tests for lots of examples on how to use in your code.**\r\n\r\nThe functor names used are as follows:\r\n\r\n * number(X) -- an integer reply was decoded, \":\" in redis speak.\r\n * bulk(X) -- a bulk reply was decoded, \"$\" in redis speak.\r\n * status(X) -- a status reply was decoded, \"+\" in redis speak.\r\n * nil -- the -1 nil response was decoded\r\n\r\nWhat about \"-\" error responses I hear you ask? Well, on advice from the protocol page I chose to throw an exception when one of these is encountered, here is the code:\r\n\r\n```prolog\r\ngpredis_parse_reply(-, SI, Out) :-\r\n        gpredis_get_line(SI, [], Out),\r\n        format_to_atom(Err, '~s', [Out]),\r\n        throw(redis_error(Err)).\r\n```\r\n\r\nSo, the exception name will be `redis_error` and it will contain an atom value that is the text of the reply.\r\n\r\n\r\nTypical return data\r\n-------------------\r\nLet's just say you wanted to get the contents of a list, here is the code:\r\n\r\n```prolog\r\nredis_connect(C),\r\nredis_do(C, lrange(my_list,0,-1), X),\r\nredis_disconnect(C).\r\n```\r\n\r\nWhat does X look like? Well if X contained a list of names it might look like:\r\n\r\n```prolog\r\n| ?- redis_connect(C),redis_do(C,lrange(my_list,0,-1),X), redis_disconnect(C).\r\n\r\nC = redis('$stream'(7),'$stream'(8),6)\r\nX = [bulk([65,108,98,101,114,116]), bulk([66,101,114,116,114,97,110,100]),\r\n     bulk([69,114,105,99]), bulk([83,101,97,110])]\r\n```\r\n\r\nSo you see, you get a list of bulk(X) values each containing the names. If you want a comparison on output styles, here is the redis() predicate output:\r\n\r\n```prolog\r\n| ?- redis(lrange(my_list,0,-1)).\r\nSTRING: Albert\r\nSTRING: Bertrand\r\nSTRING: Eric\r\nSTRING: Sean\r\n```\r\n\r\nNote that the console predicate preceded the data with its type indicator, this maps to the types from Redis. This is just so as you can see what actually came back.\r\n\r\n\r\nParting words of advice\r\n=======================\r\nThe test scripts are not exhaustive but should show how to use the most common Redis types, those being lists, sets, hashes and keys. If you have any troubles then you can get in touch via this site in the usual way.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}